<?php

namespace Supra\Package\Cms\SQL;

use Doctrine\ORM\Mapping\ClassMetadata;
use Doctrine\ORM\Query;
use Doctrine\ORM\Query\QueryException;
use Doctrine\ORM\Query\SqlWalker;
use SimpleThings\EntityAudit\AuditManager;
use Doctrine\ORM\Query\AST;

class AuditWalker extends SqlWalker
{
	const QUERY_HINT_REVISION = 'audit.hint_revision';
	const QUERY_HINT_AUDIT_MANAGER = 'audit.audit_manager';

	/**
	 * @var AuditManager
	 */
	protected $auditManager;

	protected $revision;

	public function __construct($query, $parserResult, array $queryComponents)
	{
		$this->auditManager = $query->getHint(self::QUERY_HINT_AUDIT_MANAGER);
		$this->revision = $query->getHint(self::QUERY_HINT_REVISION);

		parent::__construct($query, $parserResult, $queryComponents);
	}

//	public function getExecutor($AST)
//	{
//		if ($AST instanceof AST\SelectStatement) {
//			$AST->groupByClause = new AST\GroupByClause(
//				array(new AST\PathExpression(AST\PathExpression::TYPE_STATE_FIELD))
//			);
//		}
//
//		return parent::getExecutor($AST); // TODO: Change the autogenerated stub
//	}

	public function walkSelectStatement(AST\SelectStatement $AST)
	{
		//add group by
		//$groupings = array();
		//$class = $this->__getPrivate('em')->getClassMetadata($this->__getPrivate('rootEntityName'));
		/*foreach ($this->__getPrivate('rootAliases') as $alias) {
			$class = $this->__getPrivate('queryComponents')[$alias]['metadata'];

			if ($this->auditManager->getMetadataFactory()->isAudited($class->name)) {
				$tableAlias = $this->getSQLTableAlias($class->table['name'], $alias);

				$groupings[] = $tableAlias . '.id';
				//$revisionSqlParts[] = $tableAlias . '.' . $this->auditManager->getConfiguration()->getRevisionFieldName() .
					//' <= ' . $this->revision;
			}
		}*/

//		if ($groupings) {
//			if ($AST->groupByClause) {
//				$AST->groupByClause->groupByItems += $groupings;
//			} else {
//				$AST->groupByClause = new AST\GroupByClause($groupings);
//			}
//		}
//
		$sql = parent::walkSelectStatement($AST);

		$maxParts = array();

		foreach ($this->__getPrivate('rootAliases') as $dqlAlias) {
			$class = $this->__getPrivate('queryComponents')[$dqlAlias]['metadata'];
			$alias = $this->getSQLTableAlias($class->table['name'], $dqlAlias);

			$maxParts[] = 'MAX(' . $alias . '.' . $this->auditManager->getConfiguration()->getRevisionFieldName() . ') AS '.$alias . 'rev_max';
		}

		if ($maxParts) {
			//todo: subselects
			$sql = str_replace('SELECT ', 'SELECT ' . implode(', ', $maxParts) .  ', ', $sql);
		}

		return $sql;
	}

//	public function walkSelectExpression($selectExpression)
//	{
//		$sql = parent::walkSelectExpression($selectExpression);
//
//		//here selectedClasses should be filled already
//		//@todo: throw error if more than one class is selected
//		foreach ($this->__getPrivate('selectedClasses') as $selectedClass) {
//			/* @var ClassMetadata $selectedClass */
//			foreach ($selectedClass['class']->identifier as $column) {
//				//this does not work since we create an alias before other tables are joined
//				$tableAlias = $this->getSQLTableAlias($selectedClass['class']->table['name'], $column);
//			}
//		}
//
//		return $sql;
//	}


	public function walkWhereClause($whereClause)
	{
		$condSql  = null !== $whereClause ? $this->walkConditionalExpression($whereClause->conditionalExpression) : '';
		$discrSql = $this->__callPrivate('_generateDiscriminatorColumnConditionSql', $this->__getPrivate('rootAliases'));

		if ($this->__getPrivate('em')->hasFilters()) {
			$filterClauses = array();
			foreach ($this->__getPrivate('rootAliases') as $dqlAlias) {
				$class = $this->__getPrivate('queryComponents')[$dqlAlias]['metadata'];
				$tableAlias = $this->getSQLTableAlias($class->table['name'], $dqlAlias);

				if ($filterExpr = $this->__callPrivate('generateFilterConditionSQL', $class, $tableAlias)) {
					$filterClauses[] = $filterExpr;
				}
			}

			if (count($filterClauses)) {
				if ($condSql) {
					$condSql = '(' . $condSql . ') AND ';
				}

				$condSql .= implode(' AND ', $filterClauses);
			}
		}

		$revisionSqlParts = array();

		foreach ($this->__getPrivate('rootAliases') as $alias) {
			$class = $this->__getPrivate('queryComponents')[$alias]['metadata'];

			if ($this->auditManager->getMetadataFactory()->isAudited($class->name)) {
				$tableAlias = $this->getSQLTableAlias($class->table['name'], $alias);

				$revisionSqlParts[] = $tableAlias . '.' . $this->auditManager->getConfiguration()->getRevisionFieldName() .
					' <= ' . $this->revision;
			}
		}

		$revisionSql = implode(' AND ', $revisionSqlParts);

		if ($condSql) {
			return ' WHERE ' .
				(
					( ! $discrSql) ?
							$condSql . ($revisionSql ? ' AND ' . $revisionSql : '') :
							'(' . $condSql . ') AND ' . $discrSql . ($revisionSql ? ' AND ' . $revisionSql : '')
				);
		}

		if ($discrSql) {
			return ' WHERE ' . $discrSql .
				($revisionSql ? ' AND ' . $revisionSql : '');
		}

		return '';
	}


	public function walkJoinAssociationDeclaration($joinAssociationDeclaration, $joinType = AST\Join::JOIN_TYPE_INNER, $condExpr = null)
	{
		$sql = '';

		$associationPathExpression = $joinAssociationDeclaration->joinAssociationPathExpression;
		$joinedDqlAlias            = $joinAssociationDeclaration->aliasIdentificationVariable;
		$indexBy                   = $joinAssociationDeclaration->indexBy;

		$relation        = $this->__getPrivate('queryComponents')[$joinedDqlAlias]['relation'];
		$targetClass     = $this->__getPrivate('em')->getClassMetadata($relation['targetEntity']);
		$sourceClass     = $this->__getPrivate('em')->getClassMetadata($relation['sourceEntity']);
		$targetTableName = $targetClass->getQuotedTableName($this->__getPrivate('platform'));

		if ($this->auditManager->getMetadataFactory()->isAudited($targetClass->name)) {
			$targetTableName .= $this->auditManager->getConfiguration()->getTableSuffix();
		}

		$targetTableAlias = $this->getSQLTableAlias($targetClass->getTableName(), $joinedDqlAlias);
		$sourceTableAlias = $this->getSQLTableAlias($sourceClass->getTableName(), $associationPathExpression->identificationVariable);

		// Ensure we got the owning side, since it has all mapping info
		$assoc = ( ! $relation['isOwningSide']) ? $targetClass->associationMappings[$relation['mappedBy']] : $relation;

		if ($this->__getPrivate('query')->getHint(Query::HINT_INTERNAL_ITERATION) == true && (!$this->__getPrivate('query')->getHint(self::HINT_DISTINCT) || isset($this->__getPrivate('selectedClasses')[$joinedDqlAlias]))) {
			if ($relation['type'] == ClassMetadata::ONE_TO_MANY || $relation['type'] == ClassMetadata::MANY_TO_MANY) {
				throw QueryException::iterateWithFetchJoinNotAllowed($assoc);
			}
		}

		// This condition is not checking ClassMetadata::MANY_TO_ONE, because by definition it cannot
		// be the owning side and previously we ensured that $assoc is always the owning side of the associations.
		// The owning side is necessary at this point because only it contains the JoinColumn information.
		switch (true) {
			case ($assoc['type'] & ClassMetadata::TO_ONE):
				$conditions = array();

				foreach ($assoc['joinColumns'] as $joinColumn) {
					$quotedSourceColumn = $this->__getPrivate('quoteStrategy')->getJoinColumnName($joinColumn, $targetClass, $this->__getPrivate('platform'));
					$quotedTargetColumn = $this->__getPrivate('quoteStrategy')->getReferencedJoinColumnName($joinColumn, $targetClass, $this->__getPrivate('platform'));

					if ($relation['isOwningSide']) {
						$conditions[] = $sourceTableAlias . '.' . $quotedSourceColumn . ' = ' . $targetTableAlias . '.' . $quotedTargetColumn;

						continue;
					}

					$conditions[] = $sourceTableAlias . '.' . $quotedTargetColumn . ' = ' . $targetTableAlias . '.' . $quotedSourceColumn;
				}

				// Apply remaining inheritance restrictions
				$discrSql = $this->__callPrivate('_generateDiscriminatorColumnConditionSQL', array($joinedDqlAlias));

				if ($discrSql) {
					$conditions[] = $discrSql;
				}

				// Apply the filters
				$filterExpr = $this->__callPrivate('generateFilterConditionSQL', $targetClass, $targetTableAlias);

				if ($filterExpr) {
					$conditions[] = $filterExpr;
				}

				$sql .= $targetTableName . ' ' . $targetTableAlias . ' ON ' . implode(' AND ', $conditions);
				break;

			case ($assoc['type'] == ClassMetadata::MANY_TO_MANY):
				// Join relation table
				$joinTable      = $assoc['joinTable'];
				$joinTableAlias = $this->getSQLTableAlias($joinTable['name'], $joinedDqlAlias);
				$joinTableName  = $sourceClass->getQuotedJoinTableName($assoc, $this->__getPrivate('platform'));

				$conditions      = array();
				$relationColumns = ($relation['isOwningSide'])
					? $assoc['joinTable']['joinColumns']
					: $assoc['joinTable']['inverseJoinColumns'];

				foreach ($relationColumns as $joinColumn) {
					$quotedSourceColumn = $this->__getPrivate('quoteStrategy')->getJoinColumnName($joinColumn, $targetClass, $this->__getPrivate('platform'));
					$quotedTargetColumn = $this->__getPrivate('quoteStrategy')->getReferencedJoinColumnName($joinColumn, $targetClass, $this->__getPrivate('platform'));

					$conditions[] = $sourceTableAlias . '.' . $quotedTargetColumn . ' = ' . $joinTableAlias . '.' . $quotedSourceColumn;
				}

				$sql .= $joinTableName . ' ' . $joinTableAlias . ' ON ' . implode(' AND ', $conditions);

				// Join target table
				$sql .= ($joinType == AST\Join::JOIN_TYPE_LEFT || $joinType == AST\Join::JOIN_TYPE_LEFTOUTER) ? ' LEFT JOIN ' : ' INNER JOIN ';

				$conditions      = array();
				$relationColumns = ($relation['isOwningSide'])
					? $assoc['joinTable']['inverseJoinColumns']
					: $assoc['joinTable']['joinColumns'];

				foreach ($relationColumns as $joinColumn) {
					$quotedSourceColumn = $this->__getPrivate('quoteStrategy')->getJoinColumnName($joinColumn, $targetClass, $this->__getPrivate('platform'));
					$quotedTargetColumn = $this->__getPrivate('quoteStrategy')->getReferencedJoinColumnName($joinColumn, $targetClass, $this->__getPrivate('platform'));

					$conditions[] = $targetTableAlias . '.' . $quotedTargetColumn . ' = ' . $joinTableAlias . '.' . $quotedSourceColumn;
				}

				// Apply remaining inheritance restrictions
				$discrSql = $this->__callPrivate('_generateDiscriminatorColumnConditionSQL', array($joinedDqlAlias));

				if ($discrSql) {
					$conditions[] = $discrSql;
				}

				// Apply the filters
				$filterExpr = $this->__callPrivate('generateFilterConditionSQL', $targetClass, $targetTableAlias);

				if ($filterExpr) {
					$conditions[] = $filterExpr;
				}

				$sql .= $targetTableName . ' ' . $targetTableAlias . ' ON ' . implode(' AND ', $conditions);
				break;
		}

		// Handle WITH clause
		if ($condExpr !== null) {
			// Phase 2 AST optimization: Skip processing of ConditionalExpression
			// if only one ConditionalTerm is defined
			$sql .= ' AND (' . $this->walkConditionalExpression($condExpr) . ')';
		}

		// FIXME: these should either be nested or all forced to be left joins (DDC-XXX)
		if ($targetClass->isInheritanceTypeJoined()) {
			$sql .= $this->_generateClassTableInheritanceJoins($targetClass, $joinedDqlAlias);
		}

		// Apply the indexes
		if ($indexBy) {
			// For Many-To-One or One-To-One associations this obviously makes no sense, but is ignored silently.
			$this->__getPrivate('rsm')->addIndexBy(
				$indexBy->simpleStateFieldPathExpression->identificationVariable,
				$indexBy->simpleStateFieldPathExpression->field
			);
		} else if (isset($relation['indexBy'])) {
			$this->__getPrivate('rsm')->addIndexBy($joinedDqlAlias, $relation['indexBy']);
		}

		return $sql;
	}

	public function walkRangeVariableDeclaration($rangeVariableDeclaration)
	{
		$class    = $this->__getPrivate('em')->getClassMetadata($rangeVariableDeclaration->abstractSchemaName);
		$dqlAlias = $rangeVariableDeclaration->aliasIdentificationVariable;

		$this->__setPrivate('rootAliases', $this->__getPrivate('rootAliases') + array($dqlAlias));

		$tableName = $class->getQuotedTableName($this->__getPrivate('platform'));

		if ($this->auditManager->getMetadataFactory()->isAudited($class->name)) {
			$tableName .= $this->auditManager->getConfiguration()->getTableSuffix();
		}

		$sql = $tableName . ' '
			. $this->getSQLTableAlias($class->getTableName(), $dqlAlias);

		if ($class->isInheritanceTypeJoined()) {
			$sql .= $this->_generateClassTableInheritanceJoins($class, $dqlAlias);
		}

		return $sql;
	}

	private function _generateClassTableInheritanceJoins($class, $dqlAlias)
	{
		$sql = '';

		$baseTableAlias = $this->getSQLTableAlias($class->getTableName(), $dqlAlias);

		// INNER JOIN parent class tables
		foreach ($class->parentClasses as $parentClassName) {
			$parentClass = $this->__getPrivate('em')->getClassMetadata($parentClassName);
			$tableAlias  = $this->getSQLTableAlias($parentClass->getTableName(), $dqlAlias);

			// If this is a joined association we must use left joins to preserve the correct result.
			$sql .= isset($this->__getPrivate('queryComponents')[$dqlAlias]['relation']) ? ' LEFT ' : ' INNER ';
			$parentTableName = $this->__getPrivate('quoteStrategy')->getTableName($parentClass, $this->__getPrivate('platform'));
			if ($this->auditManager->getMetadataFactory()->isAudited($parentClass->name)) {
				$parentTableName .= $this->auditManager->getConfiguration()->getTableSuffix();
			}
			$sql .= 'JOIN ' . $parentTableName . ' ' . $tableAlias . ' ON ';

			$sqlParts = array();

			foreach ($this->__getPrivate('quoteStrategy')->getIdentifierColumnNames($class, $this->__getPrivate('platform')) as $columnName) {
				$sqlParts[] = $baseTableAlias . '.' . $columnName . ' = ' . $tableAlias . '.' . $columnName;
			}

			// Add filters on the root class
			if ($filterSql = $this->__callPrivate('generateFilterConditionSQL', $parentClass, $tableAlias)) {
				$sqlParts[] = $filterSql;
			}

			//if both classes are audited, make ON join on rev field
			if ($this->auditManager->getMetadataFactory()->isAudited($class->name) &&
				$this->auditManager->getMetadataFactory()->isAudited($parentClass->name)
			) {
				$sqlParts[] = $baseTableAlias . '.' . $this->auditManager->getConfiguration()->getRevisionFieldName() . ' = ' .
					$tableAlias . '.' . $this->auditManager->getConfiguration()->getRevisionFieldName();
			}

			$sql .= implode(' AND ', $sqlParts);
		}

		// Ignore subclassing inclusion if partial objects is disallowed
		if ($this->__getPrivate('query')->getHint(Query::HINT_FORCE_PARTIAL_LOAD)) {
			return $sql;
		}

		// LEFT JOIN child class tables
		foreach ($class->subClasses as $subClassName) {
			$subClass   = $this->__getPrivate('em')->getClassMetadata($subClassName);
			$tableAlias = $this->getSQLTableAlias($subClass->getTableName(), $dqlAlias);

			$subTableName = $this->__getPrivate('quoteStrategy')->getTableName($subClass, $this->__getPrivate('platform'));

			if ($this->auditManager->getMetadataFactory()->isAudited($subClass->name)) {
				$subTableName .= $this->auditManager->getConfiguration()->getTableSuffix();
			}

			$sql .= ' LEFT JOIN ' . $subTableName . ' ' . $tableAlias . ' ON ';

			$sqlParts = array();

			foreach ($this->__getPrivate('quoteStrategy')->getIdentifierColumnNames($subClass, $this->__getPrivate('platform')) as $columnName) {
				$sqlParts[] = $baseTableAlias . '.' . $columnName . ' = ' . $tableAlias . '.' . $columnName;
			}

			//if both classes are audited, make ON join on rev field
			if ($this->auditManager->getMetadataFactory()->isAudited($class->name) &&
				$this->auditManager->getMetadataFactory()->isAudited($subClass->name)
			) {
				$sqlParts[] = $baseTableAlias . '.' . $this->auditManager->getConfiguration()->getRevisionFieldName() . ' = ' .
					$tableAlias . '.' . $this->auditManager->getConfiguration()->getRevisionFieldName();
			}

			$sql .= implode(' AND ', $sqlParts);
		}

		return $sql;
	}

	protected function __callPrivate($method)
	{
		$ref = new \ReflectionMethod('Doctrine\ORM\Query\SqlWalker', $method);
		$ref->setAccessible(true);

		$args = func_get_args();
		array_shift($args);

		return $ref->invokeArgs($this, $args);
	}

	protected function __setPrivate($variable, $value)
	{
		$ref = new \ReflectionProperty('Doctrine\ORM\Query\SqlWalker', $variable);
		$ref->setAccessible(true);

		$ref->setValue($this, $value);
	}

	protected function __getPrivate($variable)
	{
		$ref = new \ReflectionProperty('Doctrine\ORM\Query\SqlWalker', $variable);
		$ref->setAccessible(true);

		return $ref->getValue($this);
	}


//	public function walkFromClause($fromClause)
//	{
//		/* @var $fromClause FromClause */
//		$identificationVarDecls = $fromClause->identificationVariableDeclarations;
//		$sqlParts = array();
//var_dump($identificationVarDecls);
//		foreach ($identificationVarDecls as $identificationVariableDecl) {
//			$sql = $this->platform->appendLockHint(
//				$this->walkRangeVariableDeclaration($identificationVariableDecl->rangeVariableDeclaration),
//				$this->query->getHint(Query::HINT_LOCK_MODE)
//			);
//
//			foreach ($identificationVariableDecl->joins as $join) {
//				$sql .= $this->walkJoin($join);
//			}
//
//			if ($identificationVariableDecl->indexBy) {
//				$alias = $identificationVariableDecl->indexBy->simpleStateFieldPathExpression->identificationVariable;
//				$field = $identificationVariableDecl->indexBy->simpleStateFieldPathExpression->field;
//
//				if (isset($this->scalarFields[$alias][$field])) {
//					$this->rsm->addIndexByScalar($this->scalarFields[$alias][$field]);
//				} else {
//					$this->rsm->addIndexBy(
//						$identificationVariableDecl->indexBy->simpleStateFieldPathExpression->identificationVariable,
//						$identificationVariableDecl->indexBy->simpleStateFieldPathExpression->field
//					);
//				}
//			}
//
//			$sqlParts[] = $sql;
//		}
//
//		return ' FROM ' . implode(', ', $sqlParts);
//	}


//	public function getSQLTableAlias($tableName, $dqlAlias = '')
//	{
//		$meta = $this->getEntityMeta($tableName);
//		/* @var $meta ClassMetadata */
//
//		$table = parent::getSQLTableAlias($tableName, $dqlAlias);
//
//		if ($this->auditManager->getMetadataFactory()->isAudited($meta->name)) {
//			$table = $table . $this->auditManager->getConfiguration()->getTableSuffix();
//		}
//
//		return $table;
//	}

	protected function getEntityMeta($table)
	{
		foreach ($this->getEntityManager()->getMetadataFactory()->getAllMetadata() as $classMetadata) {
			if ($classMetadata->table['name'] == $table) {
				return $classMetadata;
			}
		}
	}

}
